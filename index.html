<!doctype html> 
<!-- Copyright (C) 2018 Alkis Georgopoulos <alkisg@gmail.com>. License: GPLv3. -->
<html lang="el"> 
<head> 
  <meta charset="UTF-8" />
  <!-- Using this metatag users can't scale the page using pinchIn/out gestures on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>Αναγνώριση και αναπαραγωγή μοτίβου</title>  
  <!-- TODO: "https://code.createjs.com/1.0.0/createjs.min.js" -->
  <script src="createjs.js"></script>
  <style type="text/css">
    /* Remove margins and HTML scrollbars */
    body, html  {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
    }
    #mainCanvas {
    padding: 0;
    margin: auto;
    display: block;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    }
  </style>
</head>

<body onLoad="init();">
  <canvas id="mainCanvas" width="320" height="180">
    Your browser doesn't support HTML5!
  </canvas>
  <script>
/*
 Scaling requirements:
 * I want to be able to support full screen.
 * I don't to use a specific size like 800x600, because then even the fonts are
   scaled!
 * I want to rely on a 16:9 aspect ratio.
 So, result:
 * I resize the canvas on window.resize to fit the window while keeping 16:9.
 * I resize/reposition everything manually.
*/
// TODO: create a game global object to avoid polluting the namespace
const ratio = 16/9;
var ts = 4; // Tile Size; of course same for x and y (square pixels)
var stage, queue;
var bg, text1, progressText;
var contl, contr, contb;  // containers; left, right, bottom
var boxl, boxr, boxb;  // rounded boxes; left, right, bottom
var gridX, gridY;  // how many bitmaps in each top box
var tilesNum; // = gridX * gridY
var tiles = ['aquarela_colors', 'giraffe', 'pencil', 'mouse_on_cheese', 'mushroom_house', 'pencils_paper', 'pencils', 'white_cake', 'die_1', 'die_2', 'die_3', 'die_4', 'die_5', 'die_6', 'die_7', 'die_0',  'digital_die1', 'digital_die2', 'digital_die3', 'digital_die4', 'digital_die5', 'digital_die6', 'digital_die7', 'digital_die0'];
var tilesl = [];
var tilesr = [];
var tilesb = [];
var selectedTile;
var level = 0;

function startPreload() {
  manifest = [
    { id: "bg", src: "resource/background.png" }
  ]
  for (var i=0; i<tiles.length; i++)
    manifest.push({ id: "tile" + i, src: "resource/" + tiles[i] + ".png" })
  queue = new createjs.LoadQueue(preferXHR=true);
  // TODO: preload.installPlugin(createjs.Sound);          
  queue.on("fileload", handleFileLoad);
  queue.on("progress", handleFileProgress);
  queue.on("complete", loadComplete);
  queue.on("error", loadError);
  queue.loadManifest(manifest);
}

function handleFileLoad(event) {
  console.log("A file has loaded of type: " + event.item.type);
  if(event.item.id == "logo"){
    console.log("Logo is loaded");
    //create bitmap here
  }
}

function loadError(evt) {
  console.log("Error!",evt.text);
}

function handleFileProgress(event) {
  progressText.text = (queue.progress*100|0) + " % Loaded";
  stage.update();
}
 
function loadComplete(event) {
  console.log("Finished Loading Assets");
  bg = new createjs.Bitmap(queue.getResult("bg"));
  stage.addChild(bg);

  boxl = new createjs.Shape();
  stage.addChild(boxl);
  contl = new createjs.Container();
  stage.addChild(contl);
  for (i = 0; i < 24; i++) {
    tilesl[i] = new createjs.Bitmap(queue.getResult("tile15"));
    tilesl[i].visible = false;
    contl.addChild(tilesl[i]);
  }

  boxr = new createjs.Shape();
  stage.addChild(boxr);
  contr = new createjs.Container();
  stage.addChild(contr);
  for (i = 0; i < 24; i++) {
    tilesr[i] = new createjs.Bitmap(queue.getResult("tile15"));
    tilesr[i].visible = false;
    tilesr[i].addEventListener("click", function(event) {
  if (selectedTile) {
    event.target.image = selectedTile.image;
    checkEndGame();
    stage.update();
  }
});
    contr.addChild(tilesr[i]);
  }

  boxb = new createjs.Shape();
  stage.addChild(boxb);
  contb = new createjs.Container();
  stage.addChild(contb);
  for (i = 0; i < 24; i++) {
    tilesb[i] = new createjs.Bitmap(queue.getResult("tile15"));
    tilesb[i].visible = false;
    tilesb[i].addEventListener("click", function(event) {
  if (selectedTile)
    selectedTile.rotation = 0;
  selectedTile = event.target;
  stage.update();
});
    tilesb[i].addEventListener("mouseover", function(event) {
  event.target.scaleX = 1.2*event.target.savedscaleX;
  event.target.scaleY = 1.2*event.target.savedscaleY;
  stage.update();
});
    tilesb[i].addEventListener("mouseout", function(event) {
  event.target.scaleX = event.target.savedscaleX;
  event.target.scaleY = event.target.savedscaleY;
  stage.update();
});
    contb.addChild(tilesb[i]);
  }

  text1 = new createjs.Text("", "20px Arial", "#ffff77");
  text1.textBaseline = "alphabetic";
  stage.addChild(text1);

  initLevel();
  window.addEventListener('resize', resize, false);
  createjs.Ticker.on("tick", tick);
  createjs.Ticker.framerate = 10;
}

function init() {
  console.clear();
  stage = new createjs.Stage("mainCanvas");
  stage.enableMouseOver();
  progressText = new createjs.Text("Loading...", "30px Arial", "silver");
  stage.addChild(progressText);
  startPreload();
  // The rest of the initialization happens in loadComplete()
}

// tilesArray, tileWidth, boxWidth
function alignTiles(tilesA, tileW, boxW) {
  // We do want at least one pixel spacing between the tiles
  tilesPerRow = Math.floor(boxW/(tileW+1))
  // If all tiles fit, use that number
  tilesPerRow = Math.min(tilesA.length, tilesPerRow)
  margin = (boxW - tileW*tilesPerRow) / (tilesPerRow-1)
  for (i = 0; i < tilesA.length; i++) {
    if (!tilesA[i].image) {
      console.log(i)
      console.log(tilesA)
    }
    tilesA[i].scaleX = tileW / tilesA[i].image.width;
    tilesA[i].scaleY = tileW / tilesA[i].image.height;
    tilesA[i].regX = tilesA[i].image.width / 2;
    tilesA[i].regY = tilesA[i].image.height / 2;
    tilesA[i].x = (margin+tileW) * (i % tilesPerRow) + tilesA[i].scaleX*tilesA[i].regX;
    tilesA[i].y = (margin+tileW) * Math.floor(i / tilesPerRow) + tilesA[i].scaleY*tilesA[i].regY;
    // These copies are used to preserve the original scale on mouseover
    tilesA[i].savedscaleX = tilesA[i].scaleX;
    tilesA[i].savedscaleY = tilesA[i].scaleY;
  }
}

function resize() {
  // Resize the canvas element
  winratio = window.innerWidth/window.innerHeight;
  if (winratio >= ratio) {
    stage.canvas.height = window.innerHeight;
    stage.canvas.width = stage.canvas.height * ratio;
  } else {
    stage.canvas.width = window.innerWidth;
    stage.canvas.height = stage.canvas.width / ratio;
  }

  // Calculate the new tile size
  // We want to fit 2 boxes of gridX tiles, and 1 for spacing.
  ts = Math.floor(stage.canvas.width / (2*gridX+1));
  space = stage.canvas.width - 2*gridX*ts;

  // This depicts the spacing of the top boxes
  margin = space / (1 + (1 + (gridX - 1) + 1) + 1 + (1 + (gridX - 1) + 1) + 1);
  boxl.x = margin;
  boxl.y = margin;
  boxl.alpha = 0.5;
  boxl.graphics.clear();
  boxl.graphics.beginStroke("#000");
  boxl.graphics.setStrokeStyle(1);
  boxl.graphics.beginFill("DarkTurquoise").drawRoundRect(0, 0, gridX*ts + (gridX+1)*margin, gridY*ts + (gridY+1)*margin, margin);
  contl.x = boxl.x + margin;
  contl.y = boxl.y + margin;
  alignTiles(tilesl, ts, gridX*ts + (gridX-1)*margin);

  boxr.x = gridX*ts + (gridX+3)*margin;
  boxr.y = boxl.y;
  boxr.alpha = 0.5;
  boxr.graphics.clear();
  boxr.graphics.beginStroke("#000");
  boxr.graphics.setStrokeStyle(1);
  boxr.graphics.beginFill("OrangeRed").drawRoundRect(0, 0, gridX*ts + (gridX+1)*margin, gridY*ts + (gridY+1)*margin, margin);
  contr.x = boxr.x + margin;
  contr.y = boxr.y + margin;
  alignTiles(tilesr, ts, gridX*ts + (gridX-1)*margin);

  boxb.x = boxl.x;
  boxb.y = gridY*ts + (gridY+3)*margin;
  boxb.alpha = 0.5;
  boxb.graphics.clear();
  boxb.graphics.beginStroke("#000");
  boxb.graphics.setStrokeStyle(1);
  boxb.graphics.beginFill("DeepSkyBlue").drawRoundRect(0, 0, 2*gridX*ts + (2*gridX+3)*margin, (Math.floor(1+(tilesNum-1)/12))*ts + (Math.floor(2+(tilesNum-1)/12))*margin, margin);
  contb.x = boxb.x + margin;
  contb.y = boxb.y + margin;
  alignTiles(tilesb, ts, 2*gridX*ts + (2*gridX+1)*margin);

  text1.text = "Level: " + (level + 1 ) + ", tilesNum = " + tilesNum + ", tilesSize: " + ts;
  text1.x = margin;
  text1.y = stage.canvas.height - margin;
  text1.font = parseInt(stage.canvas.height/20) + "px Arial";

  // Fill all the canvas with the background
  bg.scaleX = stage.canvas.width / bg.image.width;
  bg.scaleY = stage.canvas.height / bg.image.height;
  
  stage.update();
}

dx = 5;
function tick() {
  if (selectedTile) {
    selectedTile.rotation += dx;
    if (Math.abs(selectedTile.rotation) > 10)
      dx = -dx;
  }
  stage.update();
}

function initLevel(newLevel=0) {
  // Internal level number is zero-based; but we display it as 1-based.
  // Levels:       0-1 2-3  4-5  6-7  8-9  10-11 12-13 14-15
  // Top layouts:  3x2 4x2  5x2  6x2  5x3   6x3   5x4   6x4
  // Bot layout:   6+0 8+0 10+0 12+0 12+3  12+6  12+8  12+12
  // Tiles number:  6   8   10   12   15    18    20    24
  // Max box sizes: left(6x4) right(6x4) bot(12x2)

  var tilesNumArr = [6, 8, 10, 12, 15, 18, 21, 24];
  var gridXArr = [3, 4, 5, 6, 5, 6, 7, 6];
  var shuffle = [];

  level = newLevel;
  i = Math.floor(level/2)
  tilesNum = tilesNumArr[i];
  gridX = gridXArr[i];
  gridY = tilesNum / gridX;

  for (i = 0; i < 24; i++) {
    tilesl[i].visible = i < tilesNum;
    tilesr[i].visible = i < tilesNum;
    tilesb[i].visible = i < tilesNum;
  }
  start = level % 4;
  if (start + tilesNum > 24)
    start = 0;
  for (i = 0; i < tilesNum; i++) {
     tilesb[i].image = queue.getResult("tile" + (start + i));
     tilesr[i].image = queue.getResult("tile15");
     shuffle[i] = start + i;
  }
  for (i = 0; i < tilesNum; i++) {
    rand = Math.floor(Math.random() * tilesNum);
    temp = shuffle[i];
    shuffle[i] = shuffle[rand];
    shuffle[rand] = temp;
  }
  for (i = 0; i < tilesNum; i++) {
     tilesl[i].image = queue.getResult("tile" + shuffle[i]);
  }
  resize();
  setTimeout("initLevel(" + (level+1) % 16 + ")", 10000);
}

function checkEndGame() {
  var endGame = true;
  for (i = 0; i < 3; i++) {
    if (tilesr[i].image.src != tilesl[i].image.src)
      endGame = false;
  }
  if (endGame)
    text1.text = "Συγχαρητήρια! Τα κατάφερες!!!";
  else
    text1.text = "Tile size: " + ts;
}
  </script>
</body>
</html>
